str(t$get_state())
t$get_split()
#Awnser for Question No 6:
t$stop()
str(t$get_state())
t$get_time()
library(lubridate)
start_time <- NA
split_time <- NA
stop_time <- NA
timer <- function()
{
list(
start = function(){start_time <<- Sys.time()},
split = function(){
if(is.na(start_time))
stop(" Error, Cannot split as timer was not started...")
else
split_time <<- Sys.time()
},
stop = function(){if(is.na(start_time))
stop("Error, Cannot stop as timer was not started...")
else
stop_time <<- Sys.time()
},
get_split = function(){if(is.na(split_time))
stop("Error, Cannot get split as split was not called...")
else
return(signif(difftime(split_time, start_time), digits = 4))
},
get_time = function(){if(is.na(stop_time))
stop("Error, Cannot get time as stop was not called...")
else
return(signif(difftime(stop_time, start_time), digits = 4))
},
get_state = function(){list(Init = Sys.time(),
start = start_time,
Finish = stop_time,
Split = split_time)}
)
}
#*****************************************************************************************************************************
#Awnser for Question No 1:
t <- timer()
str(t$get_state())
#Awnser for Question No 2:
t$split()
t$stop()
#Awnser for Question No 3:
t$start()
str(t$get_state())
#Awnser for Question No 4:
t$get_split()
t$get_time()
#Awnser for Question No 5:
t$split()
str(t$get_state())
t$get_split()
#Awnser for Question No 6:
t$stop()
str(t$get_state())
t$get_time()
install.packages("lubridate")
library(lubridate)
start_time <- NA
split_time <- NA
stop_time <- NA
timer <- function()
{
list(
start = function(){start_time <<- Sys.time()},
split = function(){
if(is.na(start_time))
stop(" Error, Cannot split as timer was not started...")
else
split_time <<- Sys.time()
},
stop = function(){
if(is.na(start_time))
stop("Error, Cannot stop as timer was not started...")
else
stop_time <<- Sys.time()
},
get_split = function(){
if(is.na(split_time))
stop("Error, Cannot get split as split was not called...")
else
return(signif(difftime(split_time, start_time), digits = 4))
},
get_time = function(){
if(is.na(stop_time))
stop("Error, Cannot get time as stop was not called...")
else
return(signif(difftime(stop_time, start_time), digits = 4))
},
get_state = function()
{
list(Init = Sys.time(),
start = start_time,
Finish = stop_time,
Split = split_time)
}
)
}
#*****************************************************************************************************************************
#Awnser for Question No 1:
t <- timer()
str(t$get_state())
#Awnser for Question No 2:
t$split()
t$stop()
#Awnser for Question No 3:
t$start()
str(t$get_state())
#Awnser for Question No 4:
t$get_split()
t$get_time()
#Awnser for Question No 5:
t$split()
str(t$get_state())
t$get_split()
#Awnser for Question No 6:
t$stop()
str(t$get_state())
t$get_time()
#install.packages("lubridate")
library(lubridate)
start_time <- NA
split_time <- NA
stop_time <- NA
timer <- function()
{
list(
start = function(){start_time <<- Sys.time()},
split = function(){
if(is.na(start_time))
stop(" Error, Cannot split as timer was not started...")
else
split_time <<- Sys.time()
},
stop = function(){
if(is.na(start_time))
stop("Error, Cannot stop as timer was not started...")
else
stop_time <<- Sys.time()
},
get_split = function(){
if(is.na(split_time))
stop("Error, Cannot get split as split was not called...")
else
return(signif(difftime(split_time, start_time), digits = 4))
},
get_time = function(){
if(is.na(stop_time))
stop("Error, Cannot get time as stop was not called...")
else
return(signif(difftime(stop_time, start_time), digits = 4))
},
get_state = function()
{
list(Init = Sys.time(),
start = start_time,
Finish = stop_time,
Split = split_time)
}
)
}
#*****************************************************************************************************************************
#Awnser for Question No 1:
t <- timer()
str(t$get_state())
#Awnser for Question No 2:
t$split()
t$stop()
#Awnser for Question No 3:
t$start()
str(t$get_state())
#Awnser for Question No 4:
t$get_split()
t$get_time()
#Awnser for Question No 5:
t$split()
str(t$get_state())
t$get_split()
#Awnser for Question No 6:
t$stop()
str(t$get_state())
t$get_time()
#install.packages("lubridate")
library(lubridate)
start_time <- NA
split_time <- NA
stop_time <- NA
timer <- function()
{
list(
start <- function(){start_time <<- Sys.time()},
split <- function(){
if(is.na(start_time))
stop(" Error, Cannot split as timer was not started...")
else
split_time <<- Sys.time()
},
stop <- function(){
if(is.na(start_time))
stop("Error, Cannot stop as timer was not started...")
else
stop_time <<- Sys.time()
},
get_split <- function(){
if(is.na(split_time))
stop("Error, Cannot get split as split was not called...")
else
return(signif(difftime(split_time, start_time), digits = 4))
},
get_time <- function(){
if(is.na(stop_time))
stop("Error, Cannot get time as stop was not called...")
else
return(signif(difftime(stop_time, start_time), digits = 4))
},
get_state <- function()
{
list(Init = Sys.time(),
start = start_time,
Finish = stop_time,
Split = split_time)
}
)
}
#*****************************************************************************************************************************
#Awnser for Question No 1:
t <- timer()
str(t$get_state())
#Awnser for Question No 2:
t$split()
t$stop()
#Awnser for Question No 3:
t$start()
str(t$get_state())
#Awnser for Question No 4:
t$get_split()
t$get_time()
#Awnser for Question No 5:
t$split()
str(t$get_state())
t$get_split()
#Awnser for Question No 6:
t$stop()
str(t$get_state())
t$get_time()
#install.packages("lubridate")
library(lubridate)
start_time <- NA
split_time <- NA
stop_time <- NA
timer <- function()
{
list(
start = function(){start_time <<- Sys.time()},
split = function(){
if(is.na(start_time))
stop(" Error, Cannot split as timer was not started...")
else
split_time <<- Sys.time()
},
stop = function(){
if(is.na(start_time))
stop("Error, Cannot stop as timer was not started...")
else
stop_time <<- Sys.time()
},
get_split = function(){
if(is.na(split_time))
stop("Error, Cannot get split as split was not called...")
else
return(signif(difftime(split_time, start_time), digits = 4))
},
get_time = function(){
if(is.na(stop_time))
stop("Error, Cannot get time as stop was not called...")
else
return(signif(difftime(stop_time, start_time), digits = 4))
},
get_state = function()
{
list(Init = Sys.time(),
start = start_time,
Finish = stop_time,
Split = split_time)
}
)
}
#*****************************************************************************************************************************
#Awnser for Question No 1:
t <- timer()
str(t$get_state())
#Awnser for Question No 2:
t$split()
t$stop()
#Awnser for Question No 3:
t$start()
str(t$get_state())
#Awnser for Question No 4:
t$get_split()
t$get_time()
#Awnser for Question No 5:
t$split()
str(t$get_state())
t$get_split()
#Awnser for Question No 6:
t$stop()
str(t$get_state())
t$get_time()
setwd("MSc_Data_Analytics_notes/ML_Assignments/Owls/")
clear
library("ggplot2")
library("dplyr")
library("lubridate")
library("readr")
library("stringr")
#********************************************* NOTE *************************************************
#Steps to run the program
#1. set the R directory to the directory where the data set is stored.
#2. Run the program. (Everything is prameterized, hence no need to call any functions)
#Note: For convinencce purpose.. Splitting of data to training (2/3) and testing (1/3)
#is already done. And calling the training and prediction function is already parametized
#and hence, no need to call the functions explicitly.
#****************************************************************************************************
Data_set = suppressMessages(read_csv("owls.csv", col_names = TRUE))
start_time = Sys.time()#To calculate elapsed time
Perceptron_Alg = function(Data_set)
{
Owl_data = Data_set
z_norm <- function(x){((x - min(x))/(max(x) - min(x)))}#Normalising data
Owl_data$Type <- as.factor(Owl_data$Type)
#Normalisation of data:
Nrm_data <- as_data_frame(sapply(Owl_data[,-5], z_norm))
Nrm_data$Type <- Owl_data$Type
set.seed(99)
index = sample(1:nrow(Nrm_data), size = (nrow(Nrm_data)*2/3), prob = NULL, replace= FALSE)
#Exploring Data
print(ggplot(Owl_data)+
geom_point(aes(x = Body_Length, y = Body_Width, colour = Type))+
ggtitle("Exploring Data")+
xlab("Body Length")+
ylab("Body Width")+
theme(plot.title = element_text(hjust = 0.5)))
#Test and Train Data Set
Test_data = Nrm_data[-index, ] #This is out tes data set. Used for validation
Train_data = Nrm_data[index, ] #This data set is further splitted according to the classification for one vs one classification
#Seperating data set according to the classification
C1_data <- Train_data[Train_data$Type == "LongEaredOwl", ] #LongEaredOwl Data
C2_data <- Train_data[Train_data$Type == "SnowyOwl", ] #SnowyOwl
C3_data <- Train_data[Train_data$Type == "BarnOwl", ] #BarnOwl
#******************* Setting up testing data *****************************************
#*************************************************************************************************
#One Vs One classification. Hence Preparing the training data accordingly
#*************************** LongEared vs Snowvy Owl *********************************************
Class_data1 <- rbind(C1_data, C2_data)
Class_data1$Type <- ifelse((Class_data1$Type == "LongEaredOwl"), 1, -1)
Train_data1 <- Class_data1[, -5]
desired_Op_Train1 <- lapply(Class_data1[, 5], function(x){x})[[1]]
#****************************** SnowyOwl vs BarnOwl *******************************************
Class_data2 <- rbind(C2_data, C3_data)
Class_data2$Type <- ifelse((Class_data2$Type == "SnowyOwl"), 1, -1)
Train_data2 <- Class_data2[, -5]
desired_Op_Train2 <- lapply(Class_data2[, 5], function(x){x})[[1]]
#********************************Barn_Owl Vs LongEaredOwl************************************
Class_data3 <- rbind(C1_data, C3_data)
Class_data3$Type <- ifelse((Class_data3$Type == "BarnOwl"), 1, -1)
Train_data3 <- Class_data3[, -5]
desired_Op_Train3 <- lapply(Class_data3[, 5], function(x){x})[[1]]
#********************************************************************************************
#                                       Training weights and bias
#*******************************************************************************************
#Default weight and bias of perceptron
Default_Bias = 0.03
lr_rate = 0.1 # Learning rate
Initial_wt = c(0.01,0.01,0.01,0.01)
#Perceptron Training
Train_Perc = function(Train_data, b, w, lr, desired)
{
Bias = b
Weights = w
m = lr#learning rate
desired_op = desired
Predicted_value = vector(mode = 'numeric', length = nrow(Train_data))
Total_RMSE = vector(mode = 'numeric', length = 100)
Learning_Weights <- function(x, y)
{
Pred_value <- Predict_value(x)
Func_x[y] <<- Pred_value
Error_L <- (desired_op[y] - Pred_value)#Error Actual - Predicted
Total_Errors <<- c(Total_Errors, Error_L)
if(Error_L != 0)
{
#Updating weights and bias if error is not zero
Bias <<- Bias + m * Error_L
Weights <<- Weights + (Error_L * m * as.numeric(x))
}
}
Predict_value = function(x)
{
#Prediction based on sum of (weights*X[i]): if sum is greater that 0 predic 1 else predict -1
value = sum(unlist(c((Weights * as.numeric(x)), Bias)))
Pred_value = ifelse((value > 0), 1, -1)
return(Pred_value)
}
#Epoch which leads to the convergence of error(if linear) or to effective dicision hyperplane
s = 0
repeat
{
Total_Errors = vector(mode = 'numeric', length = 100)
Func_x = vector(mode = 'numeric', length = nrow(Train_data))
for(i in 1:nrow(Train_data))
{
Learning_Weights(Train_data[i,], i)
}
s = s+1
RMSE = sqrt(sum(Total_Errors^2)/length(desired_op))
Total_RMSE[s] <- RMSE
if((RMSE < 0.02) | (s==1000)){
break
}
}
Predicted_value <- Func_x
#Filan values of paramtere selected
Final_param = list(Bias_va = Bias,
Weight = Weights,
Predicted_value = Predicted_value,
Actual_value = desired_op,
RMSE_Epochs = Total_RMSE
)
return(Final_param)
}
#*****************************************************************************
#Test data prediction and comparing the accuracy
Test = function(h, W, b){
Weights = W
Bias = b
Test_predict = function(x)
{
for(i in 1:nrow(x))
{
value = sum(unlist(c((Weights * as.numeric(x[i,])), Bias)))
Pred_value = ifelse((value > 0), 1, -1)
Test_predict_val[i] <<- Pred_value
}
}
Test_predict_val = vector(mode = 'numeric', length = nrow(h))
Test_predict(h)
Test_result = list(Predicted = Test_predict_val)
return(Test_result)
}
#Voting system to predicted the multiclass
Pecp_Predicted_Class = function(Predicted1,Predicted2,Predicted3)
{
Predicted_class = vector(mode = 'numeric', length = nrow(Test_data))
for(i in 1:length(Test_data$Type))
{
if((Predicted1[i] == 1) & (Predicted3[i] == -1)){
Predicted_class[i] = "LongEaredOwl"
}
if((Predicted1[i] == -1) & (Predicted2[i] == 1)){
Predicted_class[i] = "SnowyOwl"
}
if((Predicted2[i] == -1) & (Predicted3[i] == 1)){
Predicted_class[i] = "BarnOwl"
}
}
return(Predicted_class)
}
#**********************************************************************************
#Training the algorithm based on 2/3 of data: Splitting of data has been done at the begining
t = Train_Perc(Train_data1, Default_Bias, Initial_wt, lr_rate, desired_Op_Train1)
e = Train_Perc(Train_data2, Default_Bias, Initial_wt, lr_rate, desired_Op_Train2)
v = Train_Perc(Train_data3, Default_Bias, Initial_wt, lr_rate, desired_Op_Train3)
#Testing the algorithm based on testing data 1/3 : Splitting of data has been done at the begining
t1 = Test(Test_data[,-5], t$Weight, t$Bias_va)
t2 = Test(Test_data[,-5], e$Weight, e$Bias_va)
t3 = Test(Test_data[,-5], v$Weight, v$Bias_va)
#ggplot to see the error convergence if any
Learning = function(a, b, c)
{
print(ggplot()+
geom_line(aes(x = c(1:40), y = a[1:40], colour = "LongEared vs SnowyOwl"))+
geom_line(aes(x = c(1:40), y = b[1:40], colour = "SnowyOwl vs BarnOwl"))+
geom_line(aes(x = c(1:40), y = c[1:40], colour = "BarnOwl vs LongearedOwl"))+
ggtitle("Learning Error vs Epoch for each classifier")+
xlab("Eopchs")+
ylab("RMSE")+
theme(plot.title = element_text(hjust = 0.5)))
}
(Learning(t$RMSE_Epochs, e$RMSE_Epochs, v$RMSE_Epochs))
#Confusion matrix to find the missclassification
confusion_matrix = table(Actual = Test_data$Type, Predicted = Pecp_Predicted_Class(t1$Predicted,t2$Predicted,t3$Predicted))
#To display the final parameters, Accuracy  and confusion matrix on screen
op_list = list(
Confusion_Matrix = confusion_matrix,
Accuracy = ((confusion_matrix[1,1]+confusion_matrix[2,2]+confusion_matrix[3,3])/length(Test_data$Type)),
Classfier1_Weight = c(unlist(t$Weight), Bias = t$Bias_va),
Classfier2_Weight = c(unlist(e$Weight), Bias = e$Bias_va),
Classfier3_Weight = c(unlist(v$Weight), Bias = v$Bias_va),
Epochs_class1 = length(t$RMSE_Epochs),
Epochs_class2 = length(e$RMSE_Epochs),
Epochs_class2 = length(v$RMSE_Epochs)
)
print(op_list)
}
Perceptron_Alg(Data_set)
(Elapsed_time = difftime(Sys.time(), start_time))
